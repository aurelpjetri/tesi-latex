\chapter{Contesto teorico}
In questo capitolo si descrive il contesto di ricerca in cui si inserisce questo progetto di tesi, andando a descrivere lo stato dell'arte della simulazione delle masse (Sezione \ref{subsec:stato-dell-arte}) e l'approccio di ricerca in cui viene usato questo progetto di tesi (Sezione \ref{subsec:approccio-gerarchico}).\\
Successivamente si fornisce una descrizione dell'ambiente NetLogo (Sezione \ref{sec:netlogo}) e dei Design Patterns (Sezione \ref{sec:builder} e \ref{sec:visitor}) che questo progetto usa al fine di una migliore comprensione e chiarezza dei concetti esposti nel Capitolo \ref{cap:sviluppo-progetto}.
\section{Simulazione delle masse}
\label{sec:simulazione-masse}
Come già accennato nell'introduzione, la simulazione delle masse è un ambito di ricerca che negli ultimi anni ha guadagnato molta rilevanza. Questo grazie a un miglioramento delle capacità computazionali e dei metodi utilizzati, ma anche a causa di eventi sociali sempre più frequenti e di dimensioni sempre maggiori. Quindi diventa sempre più importante la capacità di prevedere i movimenti delle masse in modo da garantire la sicurezza delle persone in ogni tipo di situazione.\\
Le criticità che rendono la modellazione delle masse un problema complesso sono le grandi dimensioni dei modelli e i comportamenti individuali, sia sociali che fisici, che devono essere presi in considerazione.\\
Descriviamo brevemente gli approcci più diffusi e riconosciuti per la simulazione delle masse per andare poi a soffermarci sull'approccio gerarchico in cui si inserisce questo progetto di tesi.
\subsection{Stato dell'arte}
\label{subsec:stato-dell-arte}
Nella modellazione delle masse il maggior problema è la dimensione del modello da studiare. Le risposte ideate per risolvere questa criticità sono state molte e possono essere divise in due categorie sulla base del loro approccio: su scala microscopica e su scala macroscopica.\\
L'approccio su su scala microscopica si basa sull'idea di rappresentare ogni persona come agente o macchina a stati finiti. I tre approcci più usati sono: \textit{social force model}, \textit{cellular automata}, \textit{magnetic force model} e \textit{rule-based model}.\\
Il social force model \cite{helbing} si fonda sul concetto che le forze sociali possono essere rappresentate come forze meccaniche che agiscono tra le persone. Le forse prese in considerazione sono repulsione, attrito e dissipazione. Solitamente questi modelli arrivano ad essere molto espressivi permettendo di descrivere comportamenti sia fisici che sociali nel modello.\\
Il magnetic force model \cite{okazaki} è simile al precedente approccio, questo infatti introduce il concetto di forze magnetiche per modellare i comportamenti degli individui. Persone e ostacoli vengono modellati come poli positivi, mentre i punti di interesse, come ad esempio le uscite, sono rappresentati come poli negativi. In questo modo gli agenti sono attratti dai punti di interesse e respingono ostacoli e altre persone evitando le collisioni.\\
L'approccio cellular automata \cite{dijkstra} è caratterizzato da una griglia bidimensionale dove una cellula è definita dal proprio stato, che evolve nel tempo sulla base del proprio valore e dello stato delle cellule adiacenti. Modificando il numero di cellule che influenzano lo stato si possono rappresentare comportamenti diversi, ad esempio per il contatto fisico si usa un insieme molto ristretto di cellule, al contrario per il campo visivo si usa un numero maggiore di cellule.\\
Infine il rule-based model \cite{reynolds} presenta una modellazione dello spazio e del tempo continui e prevede che velocità e  direzione di un attore vengano modificate sulla base di determinate regole, come conformismo, anticonformismo e coesione.\\
L'approccio su macro-scala basa il proprio studio sull'analisi di caratteristiche macroscopiche della massa come la densità media e la velocità. Questa analisi viene condotta attraverso lo studio di equazioni differenziali che descrivono l'evoluzione della massa, oppure attraverso algoritmi di apprendimento e regressione applicati su dati esistenti. \\
Gli approcci più diffusi su scala macroscopica sono: \textit{regression models}, \textit{queuing models}, \textit{fluid dynamics}.\\
I regression models si basano su dati empirici dai quali cercano di estrapolare una funzione in grado di descrivere l'evoluzione della folla.\\
L'approccio fluid dynamics, invece, rappresenta gli agenti come particelle di un fluido e studia quindi le equazioni differenziali che ne descrivono i cambiamenti nel tempo.
\subsection{Approccio gerarchico}
\label{subsec:approccio-gerarchico}
L'approccio proposto da Enrico Vicario, Sandro Mehic e Marco Paolieri  in \cite{hierarchical-report} per affrontare il problema della simulazione delle masse, rispetto alle tipologie precedentemente esposte, è di tipo ibrido. Si scompone la simulazione in tre livelli di scala diversi in modo da ottenere una soluzione analitica indipendente dal numero di agenti.\\
Al primo livello si usa una modellazione di tipo microscopico basata su agenti (Agent Based Modeling, ABM) per ottenere parametri come tempo medio di soggiorno e probabilità di transizione. Oltre alle strategie di movimento si introducono due paradigmi diversi di comportamento che modellano l'aspetto sociale della folla.\\
Il primo è l'altruismo, ovvero la probabilità che un attore aiuti un altro attore con una capacità di movimento minore della sua, è stato dimostrato infatti che questa risulta essere un aspetto caratteristico delle masse. Il secondo è il conformismo, ovvero quanto questo attore tenderà ad unirsi alla massa oppure a cambiare percorso di fronte a una strada affollata.\\
L'aspetto fisico dell'attore invece, inteso come strategia di movimento, consiste nell'individuazione e raggiungimento dell'uscita più vicina. \\
Attraverso la combinazione di questi due aspetti si riescono ad ottenere comportamenti molto complessi che rispecchiano l'andamento della folla nella realtà.\\
Il secondo livello di questo approccio, ovvero il livello mesoscopico, consiste nell'astrazione dei singoli agenti delle precedenti simulazioni (\textit{Agent Based Simulations}, ABS) in catene di Markov tempo-discrete modellate usando i dati raccolti dalle ABS.\\
Ogni catena di Markov tempo-discreta, quindi, rappresenta un singolo agente in una particolare regione dello spazio e i comportamenti precedentemente osservati vengono usati per definire le probabilità di transizione nella catena individuale.
Nel terzo ed ultimo livello, quello macroscopico, si compongono le N catene di Markov parallele e le M regione spaziali adiacenti. Quindi il macroscopico spazio fisico ottenuto non è alto che un grafo con le varie regioni come nodi e i loro collegamenti come archi.\\
Come spiegato nel report di ricerca \cite{hierarchical-report}, il passo più importante di questa fase è l'approssimazione di campo medio. Usando infatti la \textit{fast simulation technique} presentata in \cite{mean-field} si è in grado di rimuovere la dipendenza del costo computazionale delle simulazioni dal numero di agenti coinvolti, permettendo, quindi, di ottenere una soluzione analitica per la simulazione di una massa che è indipendente dalle sue dimensioni.\\
In conclusione il problema del costo computazionale è risolto con l'introduzione dell'approssimazione di campo medio e la dipendenza dal numero di agenti è risolta con l'uso delle catene di Markov che li sostituisce. Inoltre il numero degli stati di queste catene è mantenuto basso grazie all'approccio gerarchico impostato.
\section {NetLogo} 
\label{sec:netlogo}
NetLogo \nocite{wilensky-tisue} \cite{netlogo} è un linguaggio di programmazione e un ambiente di modellazione di sistemi complessi. Adatto per la simulazione e lo studio di fenomeni naturali e sociali che si evolvono nel tempo.\\
Gli utenti possono dare istruzioni a migliaia di agenti che operano in modo concorrenziale. Questi comandi possono essere dati in modo individuale o collettivo, permettendo quindi lo studio dei comportamenti su più livelli, come quello microscopico dei behaviors individuali o quello macroscopico delle loro interazioni con gli altri.\\
NetLogo è usato per costruire una infinita varietà di simulazioni. I suoi turtles sono stati trasformati in molecole, lupi, clienti, commercianti, api, uccelli, batteri, macchine, magneti, pianeti, formiche e molto altro. Le sue patches allo stesso modo sono state usate come alberi, muri, corsi d'acqua, cellule tumorali, cellule vegetali e altro ancora. Turtles a patches possono essere usate per studiare astrazioni matematiche, ma anche per fare arte o giocare.\\
Tra i temi studiati con questo strumento ci sono automi cellulari, algoritmi generici, evoluzione, ottimizzazione e individuazione di percorsi, dinamiche della popolazione e società artificiali.\\
Tutti questi modelli condividono il topic centrale perseguito da questo strumento che sono i sistemi complessi e i comportamenti emergenti.\\
Il più grande miglioramento apportato a partire dalla versione 2.0 in poi riguarda la grafica. In particolare i turtles possono essere di qualsiasi forma e dimensione e soprattutto possono essere posizionati in qualsiasi punto dello spazio. La loro grafica è di tipo vettoriale in modo da non avere perdita di qualità dell'immagine a qualsiasi scala si visualizzi il modello.\\

\subsection{Storia}
Nasce a scopo educativo e di ricerca, dalla fusione di \textbf{Logo} \cite{logo} e \textbf{StarLisp} \cite{starlisp}. Dal primo eredita il principio \textit{”low threshold , no ceiling”}, ovvero bassa soglia di conoscenza per il suo utilizzo, rendendolo accessibile a utenti inesperti nella programmazione, ma allo stesso tempo completa programmabilità rendendolo quindi anche uno strumento utile per la ricerca.\\
Da Logo viene ereditato anche il concetto fondamentale di \textit{turtle}, con la differenza che Logo permetteva il controllo di un unico agente, mentre un modello NetLogo può averne migliaia. Da StarLisp, invece, NetLogo eredita i molteplici agenti e la loro \textit{concurrency}.\\
Il design di NetLogo si basa sulla precedente esperienza dei suoi creatori con StarLogoT \cite{starlogot}, di cui sono stati rielaborati quasi interamente sia l'interfaccia che il linguaggio, aggiungendo soprattutto funzionalità destinate a utenti nel campo della ricerca.

\subsection{Linguaggio}
Come Linguaggio NetLogo si evolve da Logo al quale aggiunge il concetto di agenti e di concurrency. In generale Logo è molto conoscuto per il concetto di \textbf{turtle} che ha introdotto. NetLogo generalizza questo permettendo il controllo di centinaia o migliaia di turtles che si muovono e interagiscono tra di loro.\\
Il mondo in cui i turtles si muovono è suddiviso in \textbf{patches} anche esse interamente programmabili, sia turtles che patches vengono chiamate collettivamente \textbf{agents}. Tutti gli agenti possono interagire tra di loro e eseguire istruzioni in modo concorrenziale. NetLogo include inoltre un terzo tipo di agente, l'\textbf{observer} il quale è unico. In generale l'observer è quello che impartisce ordini agli agenti.\\
Possono essere definite diverse “razze” (\textbf{breeds}) di turtles, ciascuna con variabili e behaviors caratteristici.\\
Una peculiarità che contraddistingue NetLogo dai suoi predecessori sono gli “\textit{agentsets}”, ovvero insiemi di agenti componibili anche al volo nel momento del bisogno. Questa caratteristica ha aumentato notevolmente la capacità espressiva del linguaggio.\\
Uno dei principali obbiettivi di NetLogo è quello di essere scientificamente riproducibile, quindi i suoi modelli operano in modo deterministico. Inoltre le librerie matematiche Java platform-indipendent su cui si basa aiutano a dare consistenza e a rendere NetLogo indipendente dalla macchina su cui viene eseguito.\\
Concludendo, il linguaggio presenta tutti i costrutti standard come procedure, loop, liste, integrati con particolari costrutti per il supporto alla modellazione multi-agente.

\section{Builder Pattern}
\label{sec:builder}
Lo scopo di questo pattern è quello di separare la costruzione di un oggetto complesso dalla sua rappresentazione, in modo che il medesimo processo possa essere usato per creare rappresentazioni diverse.
\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/builder-design-pattern.pdf}
\caption{Class diagram di un generico Builder}
\label{fig:builder-design-pattern}
\end{figure}
\subsection{Applicabilità}
Il pattern Builder è solitamente usato nei seguenti casi:
\begin{itemize}
\item l'algoritmo per la creazione di un oggetto deve rimanere separato dalle parti che lo costituiscono e dal modo in cui esse sono composte
\item il processo di costruzione deve rendere possibili diverse rappresentazioni dell'oggetto a cui è associato
\end{itemize}
\subsection{Partecipanti}
\begin{itemize}
\item \textbf{Builder} mette a disposizione un interfaccia per la costruzione delle parti dell'oggetto '\textit{Product}'
\item \textbf{ConcreteBuilder} 
	\begin{itemize}
	\item Costruisce le parti dell'oggetto e le assembla secondo una specifica rappresentazione.
	\item Definisce e tiene traccia delle varie rappresentazioni create.
	\item Fornisce un 'interfaccia per ottenere il Product creato.
	\end{itemize}
\item \textbf{Director} sfrutta l'interfaccia del Builder per costruire il Product.
\item \textbf{Product} è l'oggetto complesso che viene costruito. ConcreteBuilder provvede a costruire le sue parti e definisce il processo con cui vengono assemblate. 
	 
\end{itemize}
\section{Visitor Pattern}
\label{sec:visitor}


 
